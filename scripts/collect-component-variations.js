#!/usr/bin/env node

/**
 * Collect component variation metadata from Polaris MDX frontmatter.
 * Outputs a JSON payload consumed by Include System helpers and tests.
 */

const fs = require('fs');
const path = require('path');
const yaml = require('js-yaml');

const ROOT = path.resolve(__dirname, '..');
const CONTENT_ROOT = path.join(
  ROOT,
  'polaris',
  'polaris.shopify.com',
  'content',
  'components',
);
const OUTPUT_DIR = path.join(
  ROOT,
  'polaris',
  'polaris.shopify.com',
  'generated',
);
const OUTPUT_FILE = path.join(OUTPUT_DIR, 'component-variations.json');
const CONTENT_ROOT_RELATIVE = normalizePath(
  path.relative(ROOT, CONTENT_ROOT),
);
const INCLUDE_SYSTEM_GENERATED_DIR = path.join(
  ROOT,
  'packages',
  'include-system',
  'src',
  'generated',
);
const INCLUDE_SYSTEM_TS_FILE = path.join(
  INCLUDE_SYSTEM_GENERATED_DIR,
  'componentVariations.ts',
);

async function main() {
  const filePaths = await walkDir(CONTENT_ROOT);
  const components = [];

  for (const filePath of filePaths) {
    if (!filePath.endsWith('.mdx')) {
      continue;
    }

    const relativePath = path.relative(CONTENT_ROOT, filePath);
    const group = relativePath.split(path.sep)[0];
    const slug = path.basename(filePath, '.mdx');

    if (slug === 'index') {
      continue;
    }

    const raw = await fs.promises.readFile(filePath, 'utf8');
    const frontmatter = extractFrontmatter(raw);

    if (!frontmatter) {
      continue;
    }

    let data;
    try {
      data = yaml.load(frontmatter);
    } catch (error) {
      throw new Error(
        `Failed to parse frontmatter for ${relativePath}: ${error.message}`,
      );
    }

    if (!data || typeof data !== 'object') {
      continue;
    }

    const title = data.title || slug;
    const examples = Array.isArray(data.examples) ? data.examples : [];

    const variations = examples.map((example) => {
      const fileName = example.fileName || '';
      const exampleSlug = fileName.endsWith('.tsx')
        ? fileName.slice(0, -4)
        : fileName;

      return {
        fileName,
        exampleSlug,
        title: example.title || null,
        description: example.description || null,
      };
    });

    components.push({
      group,
      slug,
      title,
      path: normalizePath(relativePath),
      variationCount: variations.length,
      variations,
    });
  }

  components.sort((a, b) => {
    if (a.group === b.group) {
      return a.slug.localeCompare(b.slug);
    }
    return a.group.localeCompare(b.group);
  });

  const totals = components.reduce(
    (acc, component) => {
      acc.variationCount += component.variationCount;
      acc.componentCount += 1;
      return acc;
    },
    {componentCount: 0, variationCount: 0},
  );

  const payload = {
    generatedAt: new Date().toISOString(),
    root: CONTENT_ROOT_RELATIVE,
    totals,
    components,
  };

  await fs.promises.mkdir(OUTPUT_DIR, {recursive: true});
  await fs.promises.writeFile(
    OUTPUT_FILE,
    JSON.stringify(payload, null, 2),
    'utf8',
  );

  await fs.promises.mkdir(INCLUDE_SYSTEM_GENERATED_DIR, {recursive: true});
  const tsPayload = [
    '/* eslint-disable */',
    '// Auto-generated by scripts/collect-component-variations.js',
    '// Do not edit manually.',
    '',
    'export interface ComponentVariationDetail {',
    '  fileName: string;',
    '  exampleSlug: string;',
    '  title: string | null;',
    '  description: string | null;',
    '}',
    '',
    'export interface ComponentVariationEntry {',
    '  group: string;',
    '  slug: string;',
    '  title: string;',
    '  path: string;',
    '  variationCount: number;',
    '  variations: ComponentVariationDetail[];',
    '}',
    '',
    'export interface ComponentVariationDataset {',
    '  generatedAt: string;',
    '  root: string;',
    '  totals: { componentCount: number; variationCount: number };',
    '  components: ComponentVariationEntry[];',
    '}',
    '',
    `export const componentVariationDataset: ComponentVariationDataset = ${JSON.stringify(
      payload,
      null,
      2,
    )};`,
    '',
  ].join('\n');

  await fs.promises.writeFile(INCLUDE_SYSTEM_TS_FILE, tsPayload, 'utf8');

  console.log(
    [
      `Collected ${totals.componentCount} components`,
      `with ${totals.variationCount} variations`,
      `â†’ ${normalizePath(OUTPUT_FILE)}`,
    ].join(' '),
  );
}

async function walkDir(dir) {
  const dirents = await fs.promises.readdir(dir, {withFileTypes: true});
  const files = await Promise.all(
    dirents.map((dirent) => {
      const res = path.resolve(dir, dirent.name);
      if (dirent.isDirectory()) {
        return walkDir(res);
      }
      return res;
    }),
  );
  return files.flat();
}

function extractFrontmatter(content) {
  const frontmatterMatch = content.match(/^---\r?\n([\s\S]*?)\r?\n---/);
  if (!frontmatterMatch) {
    return null;
  }
  return frontmatterMatch[1];
}

function normalizePath(targetPath) {
  return targetPath.split(path.sep).join('/');
}

main().catch((error) => {
  console.error(error);
  process.exit(1);
});
