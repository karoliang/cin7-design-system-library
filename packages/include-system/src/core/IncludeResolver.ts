/**
 * IncludeResolver - Core resolver for include statements
 */

import {
  IncludeStatement,
  ResolvedInclude,
  IncludeResolver as IIncludeResolver,
  SupportedLanguage,
  LanguageAdapter,
  IncludeSystemConfig,
  ComponentNotFoundError,
  VariationNotFoundError,
  LanguageNotSupportedError,
  IncludeError
} from '../types/IncludeSystem';
import { componentRegistry } from '../registry/ComponentRegistry';

export class IncludeResolver implements IIncludeResolver {
  private config: IncludeSystemConfig;
  private adapters: Map<SupportedLanguage, LanguageAdapter>;
  private debugMode: boolean;

  constructor(config: IncludeSystemConfig = {}) {
    this.config = {
      enableDebugMode: false,
      strictMode: true,
      autoLoadDependencies: true,
      ...config
    };
    this.debugMode = this.config.enableDebugMode || false;
    this.adapters = new Map();
  }

  /**
   * Register a language adapter
   */
  registerAdapter(adapter: LanguageAdapter): void {
    this.adapters.set(adapter.language, adapter);
    this.debug(`Registered adapter for language: ${adapter.language}`);
  }

  /**
   * Resolve an include statement to a component
   */
  resolve(statement: IncludeStatement): ResolvedInclude {
    this.debug(`Resolving include: ${statement.language}.${statement.component}.${statement.variation}`);

    // Validate language
    if (!this.isLanguageSupported(statement.language)) {
      throw new LanguageNotSupportedError(statement.language);
    }

    // Get component and variation
    const component = componentRegistry.getComponent(statement.language, statement.component);
    const variation = componentRegistry.getVariation(
      statement.language,
      statement.component,
      statement.variation
    );

    // Generate import statement
    const adapter = this.getAdapter(statement.language);
    const importStatement = adapter.generateImport({
      statement,
      component,
      variation,
      importStatement: '', // Will be generated by adapter
      dependencies: this.getDependencies(statement.language, statement.component, statement.variation)
    });

    const resolved: ResolvedInclude = {
      statement,
      component,
      variation,
      importStatement,
      dependencies: this.getDependencies(statement.language, statement.component, statement.variation)
    };

    this.debug(`Resolved include: ${importStatement}`);
    return resolved;
  }

  /**
   * Check if a component is available
   */
  isAvailable(language: SupportedLanguage, component: string, variation?: string): boolean {
    try {
      if (!this.isLanguageSupported(language)) {
        return false;
      }

      const isComponentAvailable = componentRegistry.isAvailable(language, component);
      if (!variation) {
        return isComponentAvailable;
      }

      const variations = componentRegistry.listVariations(language, component);
      return variations.includes(variation);
    } catch (error) {
      this.debug(`Error checking availability: ${getErrorMessage(error)}`);
      return false;
    }
  }

  /**
   * List all variations for a component
   */
  listVariations(language: SupportedLanguage, component: string): string[] {
    try {
      return componentRegistry.listVariations(language, component);
    } catch (error) {
      this.debug(`Error listing variations: ${getErrorMessage(error)}`);
      return [];
    }
  }

  /**
   * List all components in a language
   */
  listComponents(language: SupportedLanguage): string[] {
    try {
      return componentRegistry.listComponents(language);
    } catch (error) {
      this.debug(`Error listing components: ${getErrorMessage(error)}`);
      return [];
    }
  }

  /**
   * List all supported languages
   */
  listLanguages(): SupportedLanguage[] {
    return componentRegistry.listLanguages();
  }

  /**
   * Resolve multiple include statements
   */
  resolveMultiple(statements: IncludeStatement[]): ResolvedInclude[] {
    const resolved: ResolvedInclude[] = [];
    const errors: string[] = [];

    for (const statement of statements) {
      try {
        const resolvedInclude = this.resolve(statement);
        resolved.push(resolvedInclude);
      } catch (error) {
        const errorMsg = `Failed to resolve include "${statement.language}.${statement.component}.${statement.variation}": ${getErrorMessage(error)}`;
        errors.push(errorMsg);
        this.debug(errorMsg);

        if (this.config.strictMode) {
          throw new IncludeError(errorMsg, 'RESOLUTION_ERROR', statement);
        }
      }
    }

    if (errors.length > 0 && !this.config.strictMode) {
      console.warn('Some includes failed to resolve:', errors);
    }

    return resolved;
  }

  /**
   * Parse include statement from string
   */
  parseIncludeStatement(includeString: string): IncludeStatement {
    const trimmed = includeString.trim();

    // Handle different formats
    if (trimmed.startsWith('include ')) {
      return this.parseIncludeFormat(trimmed);
    } else if (trimmed.startsWith('@include ')) {
      return this.parseIncludeFormat(trimmed);
    } else {
      throw new IncludeError(
        `Invalid include statement format: ${includeString}`,
        'INVALID_FORMAT'
      );
    }
  }

  /**
   * Generate code for resolved includes
   */
  generateCode(resolved: ResolvedInclude[]): string {
    const imports: string[] = [];
    const usages: string[] = [];
    const dependencies = new Set<string>();

    for (const item of resolved) {
      imports.push(item.importStatement);
      item.dependencies.forEach((dep) => dependencies.add(dep));

      const adapter = this.getAdapter(item.statement.language);
      const usageCode = adapter.generateCode(item);
      if (usageCode) {
        usages.push(usageCode);
      }
    }

    // Add dependency imports if auto-load is enabled
    if (this.config.autoLoadDependencies) {
      dependencies.forEach(dep => {
        imports.push(this.generateDependencyImport(dep));
      });
    }

    return [
      '// Generated imports',
      ...imports.filter(Boolean),
      '',
      '// Component usage',
      ...usages.filter(Boolean)
    ].join('\n');
  }

  /**
   * Enable or disable debug mode
   */
  setDebugMode(enabled: boolean): void {
    this.debugMode = enabled;
  }

  /**
   * Get configuration
   */
  getConfig(): IncludeSystemConfig {
    return { ...this.config };
  }

  /**
   * Update configuration
   */
  updateConfig(newConfig: Partial<IncludeSystemConfig>): void {
    this.config = { ...this.config, ...newConfig };
    this.debugMode = this.config.enableDebugMode || false;
  }

  // Private methods

  private isLanguageSupported(language: SupportedLanguage): boolean {
    return this.listLanguages().includes(language);
  }

  private getAdapter(language: SupportedLanguage): LanguageAdapter {
    const adapter = this.adapters.get(language);
    if (!adapter) {
      throw new IncludeError(
        `No adapter registered for language: ${language}`,
        'NO_ADAPTER'
      );
    }
    return adapter;
  }

  private getDependencies(language: SupportedLanguage, component: string, variation: string): string[] {
    try {
      const variationInfo = componentRegistry.getVariation(language, component, variation);
      return variationInfo.dependencies || [];
    } catch {
      return [];
    }
  }

  private parseIncludeFormat(includeString: string): IncludeStatement {
    // Parse: include "react" "Card" "default"
    const match = includeString.match(/(?:@include|include)\s+"([^"]+)"\s+"([^"]+)"\s+"([^"]+)"/);
    if (!match) {
      throw new IncludeError(
        `Invalid include statement format: ${includeString}`,
        'INVALID_FORMAT'
      );
    }

    const [, language, component, variation] = match;

    if (!this.isValidLanguage(language)) {
      throw new LanguageNotSupportedError(language as SupportedLanguage);
    }

    return {
      language: language as SupportedLanguage,
      component,
      variation
    };
  }

  private isValidLanguage(language: string): language is SupportedLanguage {
    return ['react', 'vanilla', 'extjs', 'typescript'].includes(language);
  }

  private generateDependencyImport(dependency: string): string {
    // Generate appropriate import based on dependency type
    if (dependency.startsWith('@shopify/polaris')) {
      return `import { ${this.extractComponentName(dependency)} } from '${dependency}';`;
    } else if (dependency.startsWith('@cin7/')) {
      return `import { ${this.extractComponentName(dependency)} } from '${dependency}';`;
    } else {
      return `import '${dependency}';`;
    }
  }

  private extractComponentName(dependency: string): string {
    // Extract component name from dependency path
    const parts = dependency.split('/');
    const lastPart = parts[parts.length - 1];
    return lastPart.charAt(0).toUpperCase() + lastPart.slice(1);
  }

  private debug(message: string): void {
    if (this.debugMode) {
      console.log(`[IncludeResolver] ${message}`);
    }
  }
}

// Default resolver instance
export const defaultResolver = new IncludeResolver({
  enableDebugMode: process.env.NODE_ENV === 'development',
  strictMode: true,
  autoLoadDependencies: true
});

function getErrorMessage(error: unknown): string {
  if (error instanceof Error) {
    return error.message;
  }
  try {
    return JSON.stringify(error);
  } catch {
    return String(error);
  }
}
